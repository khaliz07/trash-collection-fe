generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

model Package {
  id                 String         @id @default(cuid())
  name               String
  description        String?
  type               String
  duration           Int
  price              Decimal        @db.Decimal(10, 2)
  collectionsPerWeek Int            @default(2)
  features           String[]
  status             PackageStatus  @default(ACTIVE)
  isPopular          Boolean        @default(false)
  displayOrder       Int            @default(0)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  monthlyEquivalent  Decimal        @db.Decimal(10, 2)
  tier               Int            @default(1)
  payments           Payment[]
  subscriptions      Subscription[]

  @@map("packages")
}

model User {
  id                     String              @id @default(cuid())
  email                  String              @unique
  password               String
  phone                  String?
  role                   UserRole            @default(USER)
  status                 UserStatus          @default(ACTIVE)
  avatar                 String?
  dateOfBirth            DateTime?
  address                String?
  bio                    String?
  isEmailVerified        Boolean             @default(false)
  emailVerificationToken String?             @unique
  resetToken             String?             @unique
  resetTokenExpiry       DateTime?
  lastLoginAt            DateTime?
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  latitude               Float?
  longitude              Float?
  licensePlate           String?
  cccd                   String?
  rating                 Float?              @default(0)
  reviewCount            Int?                @default(0)
  startDate              DateTime?
  debtMonths             String[]
  totalDebt              Decimal             @default(0) @db.Decimal(10, 2)
  name                   String
  collectorCollections   Collection[]        @relation("CollectorCollections")
  collectorLocation      CollectorLocation[]
  debtRecords            DebtRecord[]
  feedback               Feedback[]
  notifications          Notification[]
  payments               Payment[]
  refreshTokens          RefreshToken[]
  routeAssignments       RouteAssignment[]
  schedules              Schedule[]
  subscriptions          Subscription[]
  assignedUrgentRequests UrgentRequest[]     @relation("CollectorUrgentRequests")
  urgentRequests         UrgentRequest[]     @relation("UserUrgentRequests")

  @@map("users")
}

model Subscription {
  id            String             @id @default(cuid())
  status        SubscriptionStatus @default(PENDING)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  packageId     String
  activatedAt   DateTime?
  endMonth      String
  queuePosition Int                @default(0)
  startMonth    String
  userId        String
  payments      Payment[]
  package       Package            @relation(fields: [packageId], references: [id])
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Schedule {
  id             String        @id @default(cuid())
  customerId     String
  subscriptionId String?
  frequency      FrequencyType
  dayOfWeek      Int?
  timeSlot       String
  specificTime   DateTime?
  isActive       Boolean       @default(true)
  nextCollection DateTime?
  pickupAddress  String
  latitude       Float
  longitude      Float
  instructions   String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  collections    Collection[]
  customer       User          @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@map("schedules")
}

model Collection {
  id                String           @id @default(cuid())
  collectorId       String?
  scheduleId        String?
  status            CollectionStatus @default(SCHEDULED)
  scheduledDate     DateTime
  startedAt         DateTime?
  completedAt       DateTime?
  estimatedDuration Int?
  actualDuration    Int?
  pickupAddress     String
  latitude          Float
  longitude         Float
  estimatedWeight   Float?
  actualWeight      Float?
  itemsCount        Int?
  notes             String?
  collectorNotes    String?
  beforePhotos      String[]         @default([])
  afterPhotos       String[]         @default([])
  basePrice         Decimal?         @db.Decimal(10, 2)
  additionalFees    Decimal?         @db.Decimal(10, 2)
  totalAmount       Decimal?         @db.Decimal(10, 2)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  collector         User?            @relation("CollectorCollections", fields: [collectorId], references: [id])
  schedule          Schedule?        @relation(fields: [scheduleId], references: [id])
  feedback          Feedback[]
  payment           Payment?
  routeProgress     RouteProgress?

  @@index([collectorId])
  @@index([status])
  @@index([scheduledDate])
  @@index([createdAt])
  @@map("collections")
}

model Payment {
  id             String        @id @default(cuid())
  collectionId   String?       @unique
  subscriptionId String?
  amount         Decimal       @db.Decimal(10, 2)
  currency       String        @default("VND")
  status         PaymentStatus @default(PENDING)
  paymentMethod  PaymentMethod
  transactionId  String?       @unique
  externalId     String?
  receiptUrl     String?
  paidAt         DateTime      @default(now())
  failureReason  String?
  refundedAt     DateTime?
  refundAmount   Decimal?      @db.Decimal(10, 2)
  metadata       Json?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  coveredMonths  String[]
  expiresAt      DateTime?
  packageId      String
  userId         String
  collection     Collection?   @relation(fields: [collectionId], references: [id])
  package        Package       @relation(fields: [packageId], references: [id])
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([transactionId])
  @@map("payments")
}

model DebtRecord {
  id        String     @id @default(cuid())
  userId    String
  month     String
  amount    Decimal    @db.Decimal(10, 2)
  dueDate   DateTime
  status    DebtStatus @default(UNPAID)
  paidAt    DateTime?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, month])
  @@index([userId])
  @@index([status])
  @@index([dueDate])
  @@map("debt_records")
}

model Notification {
  id          String             @id @default(cuid())
  userId      String
  title       String
  message     String
  type        NotificationType
  status      NotificationStatus @default(PENDING)
  sentAt      DateTime?
  deliveredAt DateTime?
  readAt      DateTime?
  emailData   Json?
  pushData    Json?
  smsData     Json?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model Feedback {
  id            String         @id @default(cuid())
  customerId    String
  collectionId  String
  rating        Int
  comment       String?
  status        FeedbackStatus @default(PENDING)
  adminResponse String?
  respondedAt   DateTime?
  respondedBy   String?
  categories    String[]       @default([])
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  collection    Collection     @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  customer      User           @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@map("feedback")
}

model Route {
  id                 String      @id @default(cuid())
  name               String
  description        String?
  startTime          Json
  status             RouteStatus @default(DRAFT)
  trackPoints        Json
  estimated_duration Int
  total_distance_km  Decimal?    @db.Decimal(8, 3)
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  @@map("routes")
}

model CollectionRoute {
  id                 String            @id @default(cuid())
  name               String?
  description        String?
  isActive           Boolean           @default(true)
  routeGeometry      Json?
  waypoints          Json?
  estimatedDuration  Int?
  estimatedDistance  Float?
  difficultyLevel    Int               @default(1)
  scheduledDays      String[]          @default([])
  startTime          String?
  endTime            String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  active_days        Json
  created_by         String?
  estimated_time_min Int
  route_code         String            @unique
  route_name         String
  route_path         Json
  route_polyline     String
  status             RouteStatus       @default(ACTIVE)
  time_windows       Json
  total_distance_km  Decimal           @db.Decimal(8, 3)
  work_zone_id       String?
  assignments        RouteAssignment[]
  progress           RouteProgress[]
  urgent_requests    UrgentRequest[]

  @@map("collection_routes")
}

model RouteAssignment {
  id                String           @id @default(cuid())
  routeId           String?
  collectorId       String?
  assignedDate      DateTime?
  isCompleted       Boolean          @default(false)
  startedAt         DateTime?
  completedAt       DateTime?
  totalDistance     Float?
  totalDuration     Int?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  actual_distance   Decimal?         @db.Decimal(8, 3)
  actual_duration   Int?
  assigned_date     DateTime
  collector_id      String
  completed_at      DateTime?
  route_id          String
  started_at        DateTime?
  status            AssignmentStatus @default(PENDING)
  time_window_end   String
  time_window_start String
  collector         User             @relation(fields: [collector_id], references: [id], onDelete: Cascade)
  route             CollectionRoute  @relation(fields: [route_id], references: [id], onDelete: Cascade)
  progress          RouteProgress[]

  @@unique([route_id, collector_id, assigned_date])
  @@map("route_assignments")
}

model RouteProgress {
  id            String           @id @default(cuid())
  routeId       String
  assignmentId  String
  collectionId  String           @unique
  sequenceOrder Int
  status        CollectionStatus @default(SCHEDULED)
  startedAt     DateTime?
  completedAt   DateTime?
  latitude      Float?
  longitude     Float?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  assignment    RouteAssignment  @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  collection    Collection       @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  route         CollectionRoute  @relation(fields: [routeId], references: [id], onDelete: Cascade)

  @@map("route_progress")
}

model CollectorLocation {
  id          String   @id @default(cuid())
  collectorId String
  latitude    Float
  longitude   Float
  accuracy    Float?
  heading     Float?
  speed       Float?
  isOnDuty    Boolean  @default(false)
  routeId     String?
  timestamp   DateTime @default(now())
  collector   User     @relation(fields: [collectorId], references: [id], onDelete: Cascade)

  @@index([collectorId])
  @@index([timestamp])
  @@index([isOnDuty])
  @@map("collector_locations")
}

model SystemSetting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  dataType    String   @default("string")
  description String?
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("system_settings")
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  action     String
  resource   String
  resourceId String?
  oldValues  Json?
  newValues  Json?
  ipAddress  String?
  userAgent  String?
  timestamp  DateTime @default(now())

  @@map("audit_logs")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model spatial_ref_sys {
  srid      Int     @id
  auth_name String? @db.VarChar(256)
  auth_srid Int?
  srtext    String? @db.VarChar(2048)
  proj4text String? @db.VarChar(2048)
}

model UrgentRequest {
  id                    String           @id @default(cuid())
  user_id               String
  pickup_address        String
  pickup_lat            Decimal          @db.Decimal(10, 8)
  pickup_lng            Decimal          @db.Decimal(11, 8)
  requested_date        DateTime
  urgency_level         UrgencyLevel
  waste_description     String
  assigned_route_id     String?
  assigned_collector_id String?
  assigned_at           DateTime?
  status                UrgentStatus     @default(PENDING)
  completed_at          DateTime?
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  collector             User?            @relation("CollectorUrgentRequests", fields: [assigned_collector_id], references: [id])
  route                 CollectionRoute? @relation(fields: [assigned_route_id], references: [id])
  user                  User             @relation("UserUrgentRequests", fields: [user_id], references: [id], onDelete: Cascade)

  @@map("urgent_requests")
}

enum UserRole {
  ADMIN
  USER
  COLLECTOR
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum CollectionStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  OVERDUE
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
  E_WALLET
  VNPAY
  STRIPE
}

enum SubscriptionStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
}

enum FrequencyType {
  WEEKLY
  BI_WEEKLY
  MONTHLY
  ONE_TIME
  QUARTERLY
  YEARLY
}

enum PackageStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum DebtStatus {
  UNPAID
  PAID
  OVERDUE
}

enum NotificationType {
  EMAIL
  PUSH
  SMS
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

enum FeedbackStatus {
  PENDING
  REVIEWED
  RESOLVED
}

enum RouteStatus {
  DRAFT
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum AssignmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum UrgencyLevel {
  MEDIUM
  HIGH
  CRITICAL
}

enum UrgentStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}
